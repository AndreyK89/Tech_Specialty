# Погружение в Python. Часть 1 (семинары).
# Урок 3. Коллекции.

# Задача 1. Решить задачи, которые не успели решить на семинаре.

# Задача 2. Дан список повторяющихся элементов. Вернуть список с дублирующимися элементами.
# В результирующем списке не должно быть дубликатов.

my_list = [1, 2,'a', 3, 1, 2, 3, 5, 'c', (6, 5), 'b', (6, 5),'a']

my_set = set()

for item in my_list:
    if my_list.count(item) > 1:
        my_set.add(item)
print("Исходный список", my_list)
print("Результирующий список", list(my_set))


# Задача 3. В большой текстовой строке подсчитать количество встречаемых слов и вернуть 10 самых частых.
# Не учитывать знаки препинания и регистр символов.
# За основу возьмите любую статью из википедии или из документации к языку.

import string

text = """
Python (МФА: [ˈpʌɪθ(ə)n]; в русском языке встречаются названия пито́н[18] или па́йтон[19]) — высокоуровневый язык программирования
общего назначения с динамической строгой типизацией и автоматическим управлением памятью[20][21],
ориентированный на повышение производительности разработчика, читаемости кода и его качества, а также на обеспечение
переносимости написанных на нём программ[22]. Язык является полностью объектно-ориентированным в том плане,
что всё является объектами[20]. Необычной особенностью языка является выделение блоков кода отступами[23].
Синтаксис ядра языка минималистичен, за счёт чего на практике редко возникает необходимость обращаться к документации[22].
Сам же язык известен как интерпретируемый и используется в том числе для написания скриптов[20].
Недостатками языка являются зачастую более низкая скорость работы и более высокое потребление памяти написанных на нём
программ по сравнению с аналогичным кодом, написанным на компилируемых языках, таких как C или C++[20][22].
Python является мультипарадигменным языком программирования, поддерживающим императивное, процедурное, структурное,
объектно-ориентированное программирование[20], метапрограммирование[24] функциональное программирование[20] и асинхронное
программирование[25]. Задачи обобщённого программирования решаются за счёт динамической типизации[26][27].
Аспектно-ориентированное программирование частично поддерживается через декораторы[28], более полноценная поддержка
обеспечивается дополнительными фреймворками[29]. Такие методики как контрактное и логическое программирование можно
реализовать с помощью библиотек или расширений[30]. Основные архитектурные черты — динамическая типизация,
автоматическое управление памятью[20], полная интроспекция, механизм обработки исключений, поддержка многопоточных
вычислений с глобальной блокировкой интерпретатора (GIL)[31], высокоуровневые структуры данных.
Поддерживается разбиение программ на модули, которые, в свою очередь, могут объединяться в пакеты[32].
"""

for char in string.punctuation:
    text = text.lower().replace(char, ' ')

counter_dict = {}

for word in text.split():
    counter_dict[word] = counter_dict.get(word, 0) + 1

counter_dict = tuple(sorted(counter_dict.items(), key=lambda item: item[1]))
for index, word in enumerate(counter_dict[-1:-11:-1], 1):
    print(f'{index}. {word[0]:>10} {word[1]} раз')



# Задача 4. Создайте словарь со списком вещей для похода в качестве ключа и их массой в качестве значения.
# Определите какие вещи влезут в рюкзак передав его максимальную грузоподъёмность.
# Достаточно вернуть один допустимый вариант. Верните все возможные варианты комплектации рюкзака.

carrying_capacity = int(input('Введите грузоподъемность рюкзака: '))

list_of_equipment = {'Продукты,': 5,
                     'Вода,': 2,
                     'Палатка,': 6,
                     'Мяч,': 0.5,
                     'Шампура,': 1,
                     'Одежда,': 5,
                     'Фонарик,': 3,
                     'Спальный мешок,': 9,
                     'Топор,': 3.5,
                     'Нож,': 0.2}


def sort_list(some_set: set):
    global global_list
    if len(some_set) == 1:
        return some_set
    else:
        for item in some_set:
            new_set = some_set.copy()
            new_set.remove(item)
            global_list.add(tuple(sort_list(new_set)))
    return some_set


list_of_equipment = dict(sorted(list_of_equipment.items(), key=lambda x: x[1]))
global_list = {tuple(list_of_equipment)}
sort_list(set(list_of_equipment))

print(f'В рюкзак грузоподъемностью {carrying_capacity}кг может влезть:')

for stack in global_list:
    summ_stack = 0
    for item in stack:
        summ_stack += list_of_equipment.get(item)
        if summ_stack > carrying_capacity:
            break
    else:
        print(*stack, 'весом','=', summ_stack, 'кг')